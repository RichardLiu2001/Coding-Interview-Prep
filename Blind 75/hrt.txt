# you can write to stdout for debugging purposes, e.g.
# print("this is a debug message")

def solution(N, A, B):
    
    # stores how many edges there are from each vertex
    edge_counts = {}

    for i in range(len(A)):
        start = A[i]
        dest = B[i]

        if start not in edge_counts:
            edge_counts[start] = 0

        if dest not in edge_counts:
            edge_counts[dest] = 0

        edge_counts[start] = edge_counts[start] + 1
        edge_counts[dest] = edge_counts[dest] + 1

    total_sum = 0

    vertices_sorted_by_edges = sorted(edge_counts.items(), key=lambda x:x[1], reverse=True)
    largest_val = N

    # iterate over all vertices with edges (vertices without edges are not in the list)
    for vertex in vertices_sorted_by_edges:
    
        num_edges = vertex[1]

        # assign vertices with highest edge counts the highest numbers 
        # each node contributes its value num_edges times.
        total_sum += largest_val * num_edges

        largest_val -= 1

    return total_sum

# you can write to stdout for debugging purposes, e.g.
# print("this is a debug message")

def solution(S):
    if len(S) < 2:
        return S

    while len(S) >= 2:
        
        old_S = S
        S = remove_first_adjacent(S)

        # Cannot remove any adjacent letters
        if old_S == S:
            return S

    return S


def remove_first_adjacent(S):

    for i in range(len(S) - 1):
        cur_letter = S[i]
        next_letter = S[i + 1]
        
        if (cur_letter == 'A' and next_letter == 'B') or  (cur_letter == 'B' and next_letter ==     'A') or (cur_letter == 'C' and next_letter == 'D') or (cur_letter == 'D' and next_letter == 'C'):

            return S[:i] + S[(i + 2):]
    
    return S


# you can write to stdout for debugging purposes, e.g.
# print("this is a debug message")

MARK_CONSTANT = 10

def solution(K, A):
    # write your code in Python 3.6
    num_houses = 0

    for row in range(len(A)):
        for col in range(len(A[0])):
            cell = A[row][col]
            # house
            if cell == 1:
                num_houses += 1
                mark_plots(K, row, col, A)
    
    new_branch_val = MARK_CONSTANT + num_houses - 1
    new_branch_count = 0

    for row in range(len(A)):
        for col in range(len(A[0])):
            cell = A[row][col]
            if cell == new_branch_val:
                new_branch_count += 1
    
    return new_branch_count



# mark all plots that are close enough to this house
def mark_plots(max_distance, house_row, house_col, A):
    for i in range(-1* max_distance, max_distance + 1):
        for j in range(-1* max_distance, max_distance + 1):

            # check in bounds
            # check its within max distance
            if (abs(i) + abs(j)) > max_distance or (not in_bounds(house_row + i, house_col + j, A)):
                continue

            cur_plot_val = A[house_row + i][house_col + j]

            # already a house here
            if cur_plot_val == 1:
                continue

            marked_val = cur_plot_val
            # empty plot
            if cur_plot_val == 0:
                marked_val = MARK_CONSTANT
            else:
                # already been marked by another house, increment this value
                marked_val = cur_plot_val + 1

            A[house_row + i][house_col + j] = marked_val


def in_bounds(row, col, A):
    return row >= 0 and col >= 0 and row < len(A) and col < len(A[0])

