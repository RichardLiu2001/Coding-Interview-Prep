// you can also use imports, for example:
// import java.util.*;

// you can write to stdout for debugging purposes, e.g.
// System.out.println("this is a debug message");

class Solution {
    public int solution(int[] A) {
        
        int result = 0;

        // index of the rightmost bulb that is turned on (1 based indexing)
        int rightMostBulbOn = 0;

        for (int i = 0; i < A.length; i ++) {
            
            int currentBulb = A[i];

            rightMostBulbOn = Math.max(currentBulb, rightMostBulbOn);

            int numBulbsOn = i + 1;

            // all bulbs before (to the left) must have been turned on
            if (rightMostBulbOn == numBulbsOn) {
                result ++;
            }
        }

        return result;

    }
}

// you can also use imports, for example:
import java.util.*;
// you can write to stdout for debugging purposes, e.g.
// System.out.println("this is a debug message");

class Solution {

    public int solution(String S) {

        try {
            Machine m = new Machine();
            Scanner stringScanner = new Scanner(S);

            while (stringScanner.hasNext()) {

                String currentCommand = stringScanner.next();

                switch (currentCommand) {

                    case "POP":
                        m.pop();
                        break;

                    case "DUP" :
                        m.dup();
                        break;
                    
                    case "+":
                        m.add();
                        break;

                    case "-":
                        m.subtract();
                        break;
                    
                    default:
                        // Assuming a valid number, per the question description
                        int currentInt = Integer.parseInt(currentCommand);
                        m.push(currentInt);
                }

            }

            return m.pop();

        } catch (Exception e) {
            // Should print exception, but for the test cases, I will not do it here.
            return -1;
        }
    }
}

 class Machine {
    
    final int OVERFLOW = 0xFFFFF; // equals 2^20 - 1

    public Stack<Integer> stack;

    public Machine() {
        stack = new Stack<>();
    }

    public int push(int num) {
        return stack.push(num);
    }

    public int pop() {
        
        // java stack will throw exception if stack is empty
        return stack.pop();
    }

    public int dup() {

        // java stack will throw exception if stack is empty
        int top = stack.peek();
        return stack.push(top);

    }

    public int add() {

        // java stack will throw exception if stack is empty in either call to pop
        int first = stack.pop();
        int second = stack.pop();

        checkOverflow(first + second);
        return stack.push(first + second);

    }

    public int subtract() {

        // java stack will throw exception if stack is empty in either call to pop
        int first = stack.pop();
        int second = stack.pop();

        checkOverflow(first - second);
        return stack.push(first - second);

    }

    public void checkOverflow(int n) {
        
        if (n > OVERFLOW) {
            throw new IllegalArgumentException(n + " overflows.");
        }

        if (n < 0) {
            throw new IllegalArgumentException(n + "underflows.");
        }

    }

}

// you can also use imports, for example:
import java.util.*;

// you can write to stdout for debugging purposes, e.g.
// System.out.println("this is a debug message");

class Solution {

    final int MAX = 1000000000;

    public int solution(int[] A, int S) {

        int result = 0;

        for (int i = 0; i < A.length; i ++) {
            // sum of fragment from i to j
            int fragmentSum = 0;

            // start j at i to also consider single elements as fragments of length 1
            for (int j = i; j < A.length; j ++) {
                fragmentSum += A[j];
                int fragmentLength = j - i + 1;

                // since S is an integer, the average must be a whole number
                if (fragmentSum % fragmentLength != 0) {
                    continue;
                }

                if (fragmentSum / fragmentLength == S) {
                    result ++;
                    if (result >= MAX) {
                        return result;
                    }
                }
            }
        }

        return result;

    }

    // passes tests, but not completely sure that it works on all cases
    // O(N)
    public int newSolution(int[] A, int S) {
        int result = 0;

        HashMap<Long, Integer> cumSumFreqs = new HashMap<>();

        long cumSum = 0;

        for (int i = 0; i < A.length; i ++) {

            int current = A[i];

            cumSum += current - S;

            if (cumSum == 0) {
                result ++;
            }
            
            int cumSumFreq = cumSumFreqs.getOrDefault(cumSum, 0);
            result += cumSumFreq;
            if (result >= MAX) {
                return MAX;
            }

            cumSumFreqs.put(cumSum, cumSumFreq + 1);

        }


        return result;

    }
}

